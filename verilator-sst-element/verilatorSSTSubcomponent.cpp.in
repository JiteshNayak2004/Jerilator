//
// _verilatorSSTSubcomponent_cpp_
//
// Copyright (C) 2017-2024 Tactical Computing Laboratories, LLC
// All Rights Reserved
// contact@tactcomplabs.com
//
// See LICENSE in the top level directory for licensing details
//

#include "verilatorSSTSubcomponent.h"

namespace SST::VerilatorSST{

/// helper to convert size from bits to bytes
inline uint32_t SignalHelper::calculateNumBytes(){
  const auto bytes = 1+((Width-1)/(sizeof(uint8_t)*8));
  return bytes;
}

/// helper to convert size from bits to words
inline uint32_t SignalHelper::calculateNumWords(){
  const auto words = 1+((Width-1)/(sizeof(uint32_t)*8));
  return words;
}

/// helper to convert array (vector) type
inline std::vector<uint32_t> SignalHelper::uint8ArrToUint32Arr(std::vector<uint8_t> src, uint32_t bytesPerRow, uint64_t rows){
  //const auto wordsPerRow = calculateNumWords(bytesPerRow*8);
  const auto wordsPerRow = calculateNumWords(); // TODO: this is probably outputting the wrong number
  printf("%s: wordsPerRow=%d\n", __func__, wordsPerRow);
  auto buf = std::vector<uint32_t>(wordsPerRow*rows, 0U);

  for(auto i = 0; i < rows; i++){
    auto rowBuf = std::vector<uint32_t>(wordsPerRow, 0U);
    for(auto k = 0; k < bytesPerRow; k++){
      reinterpret_cast<uint8_t*>(rowBuf.data())[k] = src[(i*bytesPerRow)+k];
    }

    for(auto j = 0; j < wordsPerRow; j++){
      uint32_t mask = (1 << (bytesPerRow*8)) - 1;
      buf[(i*wordsPerRow)+j] = rowBuf[j] & mask;
    }
  }

  return buf;
}

/// helper to convert array (vector) type
inline std::vector<uint8_t> SignalHelper::uint32ArrToUint8Arr(std::vector<uint32_t> src, uint32_t bytesPerRow, uint64_t rows){
  //const auto wordsPerRow = calculateNumWords(bytesPerRow*8);
  const auto wordsPerRow = calculateNumWords();
  auto buf = std::vector<uint8_t>(bytesPerRow*rows, 0U);

  for(auto i=0;i<rows;i++){
    //auto rowBuf = new uint8_t[bytesPerRow];
    auto rowBuf = std::vector<uint8_t>(bytesPerRow, 0U);
    
    for(auto j=0;j<wordsPerRow;j++){
      for(auto k=0;k<sizeof(uint32_t);k++){
        rowBuf[(j*sizeof(uint32_t))+k] = reinterpret_cast<const uint8_t*>(src.data()+i*wordsPerRow+j)[k];
      }
    }

    for(auto j=0;j<bytesPerRow;j++){
      buf[(i*bytesPerRow)+j] = rowBuf[j];
    }

  }

  return buf;
}

/// helper to read a row from the VPI vector representation into an existing p_vpi_value
inline bool SignalHelper::readIn(const s_vpi_value &row, p_vpi_value existing){
    assert(NextRow < Depth && "cannot add more rows");
    assert(row.format == SIGNAL_VPI_FORMAT && "all rows must be SIGNAL_VPI_FORMAT");

    unsigned words = calculateNumWords();
    existing[NextRow].format = SIGNAL_VPI_FORMAT;
    existing[NextRow].value.vector = new s_vpi_vecval[words];
    std::memcpy(existing[NextRow].value.vector, row.value.vector, words*sizeof(uint32_t));
    
    NextRow++;  

    if(NextRow == Depth){
        //Signal * signal = new Signal(bits,depth,storage);
        //storage = nullptr;

        return true;
    }
    return false;
}

/// helper to produce uint8_t vector from the VPI representation
inline std::vector<uint8_t> SignalHelper::getUIntVector(p_vpi_value extStorage){

  unsigned words = calculateNumWords();
  unsigned bytes = calculateNumBytes();
  auto buf = std::vector<uint32_t>(words, 0U);

  for (unsigned j=0; j<Depth; j++) {
    for(unsigned i=0; i<words; i++){
      buf[j*words+i] = extStorage[j].value.vector[i].aval;
    }
  }
  auto ret = uint32ArrToUint8Arr(buf,bytes,1);

  return ret;
}

inline void SignalHelper::putVpiValue(std::vector<uint8_t> data, p_vpi_value extStorage){
    const unsigned words = calculateNumWords();
    const unsigned bytes = calculateNumBytes();

    auto buf = uint8ArrToUint32Arr(data,bytes,Depth);
    
    for(auto i=0;i<Depth;i++){
      //auto row = descending ? &storage[depth-i-1] : &storage[i];
      //auto row = &extStorage[Depth-i-1];
      auto row = &extStorage[i];
      row->format = SIGNAL_VPI_FORMAT;
      for(auto k=0;k<words;k++){
        row->value.vector = new s_vpi_vecval[words];
        row->value.vector[k].aval = buf[(i*words)+k];
      }
    }
}

inline void SignalHelper::freeVpiValue(p_vpi_value extStorage) {
  for(auto i=0;i<Depth;i++){
    delete[] extStorage[i].value.vector;
  }
  delete[] extStorage;
}

// ---------------------------------------------------------------
// VerilatorSSTBase
// ---------------------------------------------------------------
VerilatorSSTBase::VerilatorSSTBase( std::string DerivedName,
                                    ComponentId_t id, const Params& params )
  : SubComponent(id), output(nullptr){
  verbosity = params.find<uint32_t>("verbose");
  std::string outStr = "[" + DerivedName + " @t]: ";
  output = new SST::Output(outStr, verbosity, 0,
                           SST::Output::STDOUT);
}

VerilatorSSTBase::~VerilatorSSTBase(){
  delete output;
}

// ---------------------------------------------------------------
// VerilatorSST@VERILOG_DEVICE@
// ---------------------------------------------------------------
VerilatorSST@VERILOG_DEVICE@::VerilatorSST@VERILOG_DEVICE@(ComponentId_t id,
                                                           const Params& params)
  : VerilatorSSTBase("@VERILOG_DEVICE@", id, params), UseVPI(false){

  UseVPI = params.find<bool>("useVPI", false);
  const std::string clockFreq = params.find<std::string>("clockFreq", "1GHz");

  clockPort = params.find<std::string>("clockPort", "NullPort");
  if( !isNamedPort(clockPort) ){
    output->fatal(CALL_INFO, -1, "Could not find clock port with name=%s\n",
                  clockPort.c_str());
  }

  // init verilator interfaces
  ContextP = new VerilatedContext();
  ContextP->threads(1);
  ContextP->debug(VL_DEBUG);
  ContextP->randReset(2);
  ContextP->traceEverOn(true);
  const char *empty {};
  ContextP->commandArgs(0,&empty);
  Top = new VTop(ContextP, "");
#if VL_DEBUG == 1
  ContextP->internalsDump();
#endif

  // attempt to build the reset value tables
  initResetValues(params);

  // register the clock
  registerClock(clockFreq,
                new Clock::Handler<VerilatorSST@VERILOG_DEVICE@>(this,
                                                                 &VerilatorSST@VERILOG_DEVICE@::clock));
}

VerilatorSST@VERILOG_DEVICE@::~VerilatorSST@VERILOG_DEVICE@(){
  delete Top;
  delete ContextP;
}

void VerilatorSST@VERILOG_DEVICE@::splitStr(const std::string& s,
                                            char c,
                                            std::vector<std::string>& v){
  std::string::size_type i = 0;
  std::string::size_type j = s.find(c);
  v.clear();

  if( (j==std::string::npos) && (s.length() > 0) ){
    v.push_back(s);
    return ;
  }

  while (j != std::string::npos) {
    v.push_back(s.substr(i, j-i));
    i = ++j;
    j = s.find(c, j);
    if (j == std::string::npos)
      v.push_back(s.substr(i, s.length()));
  }
}

void VerilatorSST@VERILOG_DEVICE@::pollWriteQueue(){
  uint64_t currTick = getCurrentTick();
  for (auto it=WriteQueue.begin(); it!=WriteQueue.end();) {
    auto ele = *it;
    if (ele.AtTick == currTick) {
      if (UseVPI) {
        writePortVPI(ele.PortName, ele.Packet);
      } else {
        unsigned Idx = PortMap.at(ele.PortName);
        DirectWriteFunc Func = std::get<V_WRITEFUNC>(Ports[Idx]);
        (*Func)(Top,ele.Packet);
      }
      it = WriteQueue.erase(it);
    } else {
      it++;
    }
  }
}

void VerilatorSST@VERILOG_DEVICE@::initResetValues(const Params& params){
  std::vector<std::string> optList;
  params.find_array("resetVals", optList);

  for( unsigned i=0; i<optList.size(); i++ ){
    std::vector<std::string> vstr;
    std::string s = optList[i];
    splitStr(s, ':', vstr);

    if( vstr.size() != 2 ){
      output->fatal(CALL_INFO, -1,
                    "Error in reading reset value from parameter list:%s\n",
                    s.c_str() );
    }

    if( !isNamedPort(vstr[0]) ){
      output->fatal(CALL_INFO, -1,
                    "Error in reading reset value: %s is not a named port\n",
                    vstr[0].c_str());
    }

    UnitAlgebra ua;
    ua.init(vstr[1]);

    ResetVals.push_back(std::make_pair(vstr[0],ua.getValue().toUnsignedLong()));
  }
}

void VerilatorSST@VERILOG_DEVICE@::init(unsigned int phase){
}

void VerilatorSST@VERILOG_DEVICE@::setup(){
}

void VerilatorSST@VERILOG_DEVICE@::finish(){
  Top->final();
}

bool VerilatorSST@VERILOG_DEVICE@::clock(SST::Cycle_t cycle){
  pollWriteQueue();
  ContextP->timeInc(1);
  Top->eval();
  return false;
}

bool VerilatorSST@VERILOG_DEVICE@::isNamedPort(std::string PortName){

  for( unsigned i=0; i<Ports.size(); i++ ){
    if( std::get<V_NAME>(Ports[i]) == PortName ){
      return true;
    }
  }

  return false;
}

unsigned VerilatorSST@VERILOG_DEVICE@::getNumPorts(){
  return Ports.size();
}

const std::vector<std::string> VerilatorSST@VERILOG_DEVICE@::getPortsNames(){
  std::vector<std::string> Names;

  for( unsigned i=0; i<Ports.size(); i++ ){
    Names.push_back(std::get<V_NAME>(Ports[i]));
  }

  return Names;
}

bool VerilatorSST@VERILOG_DEVICE@::getPortType(std::string PortName,
                                               SST::VerilatorSST::VPortType& Type){
  unsigned Idx = 0;
  try{
    Idx = PortMap.at(PortName);
  }catch(const std::out_of_range& oor){
    output->fatal(CALL_INFO, -1, "Could not find port with name=%s\n",
                  PortName.c_str());
    return false;
  }

  Type = std::get<V_TYPE>(Ports[Idx]);
  return true;
}

bool VerilatorSST@VERILOG_DEVICE@::getPortWidth(std::string PortName,
                                                unsigned& Width){
  unsigned Idx = 0;
  try{
    Idx = PortMap.at(PortName);
  }catch(const std::out_of_range& oor){
    output->fatal(CALL_INFO, -1, "Could not find port with name=%s\n",
                  PortName.c_str());
    return false;
  }

  Width = std::get<V_WIDTH>(Ports[Idx]);
  return true;
}

bool VerilatorSST@VERILOG_DEVICE@::getPortDepth(std::string PortName,
                                                unsigned& Depth){
  unsigned Idx = 0;
  try{
    Idx = PortMap.at(PortName);
  }catch(const std::out_of_range& oor){
    output->fatal(CALL_INFO, -1, "Could not find port with name=%s\n",
                  PortName.c_str());
    return false;
  }

  Depth = std::get<V_DEPTH>(Ports[Idx]);
  return true;
}

bool VerilatorSST@VERILOG_DEVICE@::getResetVal(std::string PortName,
                                               uint64_t& Val){
  unsigned Idx = 0;
  try{
    Idx = PortMap.at(PortName);
  }catch(const std::out_of_range& oor){
    output->fatal(CALL_INFO, -1, "Could not find port with name=%s\n",
                  PortName.c_str());
    return false;
  }

  for( unsigned i=0; i<ResetVals.size(); i++ ){
    if( ResetVals[i].first == PortName ){
      Val = ResetVals[i].second;
      return true;
    }
  }

  return false;
}

uint64_t VerilatorSST@VERILOG_DEVICE@::getCurrentTick(){
  return ContextP->time();
}

std::vector<uint8_t> VerilatorSST@VERILOG_DEVICE@::readPortVPI(std::string PortName){
  vpiHandle vh1 = vpi_handle_by_name((PLI_BYTE8 *)PortName.data(), NULL);
  assert(vh1 && "vpi should return a handle (port not found)");

  auto vpiTypeVal = vpi_get(vpiType, vh1);
  auto vpiSizeVal = vpi_get(vpiSize, vh1);

  std::vector<uint8_t> d;

  if(vpiTypeVal == vpiReg){
    s_vpi_value val{vpiVectorVal};
    vpi_get_value(vh1, &val);
    
    //auto signalFactory = SignalFactory(vpiSizeVal,1);
    //auto signalPtr = signalFactory(val);
    //Signal signal = std::move(*signalPtr);
    //delete signalPtr;
    //return signal;
    s_vpi_value sigData;;
    SignalHelper S(vpiSizeVal); //vpiSizeVal has the width of the port, default Depth=1
    S.readIn(val,(p_vpi_value)&sigData);
    d = S.getUIntVector((p_vpi_value)&sigData);
    return d;
  }

  if(vpiTypeVal == vpiMemory){
    vpiHandle iter = vpi_iterate(vpiMemoryWord,vh1);
    assert(iter);

    bool first = true;
    s_vpi_value vpiData[vpiSizeVal];
    SignalHelper * helper;
    while(auto rowHandle = vpi_scan(iter)){
      if(first){
        const auto rowSizeBits = vpi_get(vpiSize, rowHandle);
        helper = new SignalHelper(rowSizeBits, vpiSizeVal);
        first = false;
      }

      s_vpi_value row{SIGNAL_VPI_FORMAT};
      vpi_get_value(rowHandle, &row);
      helper->readIn(row, (p_vpi_value)vpiData);

      vpi_free_object(rowHandle);
    }
    d = helper->getUIntVector((p_vpi_value)vpiData);
    delete helper;
    return d;
  }
  assert(false && "unsupported vpiType");
  return d;
}

void VerilatorSST@VERILOG_DEVICE@::writePortVPI(std::string PortName,
                                                std::vector<uint8_t> Packet){
  vpiHandle vh1 = vpi_handle_by_name(PortName.data(), NULL);
  assert(vh1 && "vpi should return a handle (port not found)");

  auto vpiTypeVal = vpi_get(vpiType, vh1);
  auto vpiSizeVal = vpi_get(vpiSize, vh1);
  

  auto vpiDirVal = vpi_get(vpiDirection,vh1);
  assert(vpiDirVal == vpiInput && "port must be an input, inout not supported");

  if(vpiTypeVal == vpiReg){
    SignalHelper S(vpiSizeVal);
    s_vpi_value val;
    S.putVpiValue(Packet, (p_vpi_value)&val);
    //t_vpi_value val = signal.getVpiValue(0);
    vpi_put_value(vh1,&val,NULL,vpiNoDelay);
    return;
  }

  if(vpiTypeVal == vpiMemory){
    vpiHandle iter = vpi_iterate(vpiMemoryWord,vh1);
    assert(iter);

    SignalHelper * helper;
    unsigned i = 0;
    p_vpi_value storage;
    while(auto rowHandle = vpi_scan(iter)){
      auto rowSizeBits = vpi_get(vpiSize, rowHandle);
      if (i == 0) {
        helper = new SignalHelper(rowSizeBits, vpiSizeVal);
        storage = new s_vpi_value[vpiSizeVal];
        // putVpiValue fills storage with Packet data, creates vecvals on heap
        // so free helper function needs to be called at the end
        helper->putVpiValue(Packet, storage);
      }

      //t_vpi_value val = signal.getVpiValue(i);
      vpi_put_value(rowHandle,&storage[i],NULL,0);

      vpi_free_object(rowHandle);
      i++;
    }
    helper->freeVpiValue(storage);
    delete helper;

    return;
  }
  assert(false && "unsupported vpiType");
}

void VerilatorSST@VERILOG_DEVICE@::writePort(std::string PortName,
                                             std::vector<uint8_t> Packet){
  // sanity check
  if( !isNamedPort(PortName) ){
    output->fatal(CALL_INFO, -1, "Could not find port with name=%s\n",
                  PortName.c_str());
  }

  // determine which write to use
  if( UseVPI ){
    writePortVPI(PortName, Packet);
  }else{
    unsigned Idx = PortMap.at(PortName);
    DirectWriteFunc Func = std::get<V_WRITEFUNC>(Ports[Idx]);
    (*Func)(Top,Packet);
  }
}

void VerilatorSST@VERILOG_DEVICE@::writePortAtTick(std::string PortName,
                                                   std::vector<uint8_t> Packet,
                                                   uint64_t Tick){
  // sanity check
  if( !isNamedPort(PortName) ){
    output->fatal(CALL_INFO, -1, "Could not find port with name=%s\n",
                  PortName.c_str());
  }

  // Tick is used as a delay/offset, not a definite tick value
  // VPI/Direct is decided when polling the WriteQueue
  WriteQueue.emplace_back(PortName, Tick+getCurrentTick(), Packet);
}

std::vector<uint8_t> VerilatorSST@VERILOG_DEVICE@::readPort(std::string PortName){
  std::vector<uint8_t> data;

  // sanity check
  if( !isNamedPort(PortName) ){
    output->fatal(CALL_INFO, -1, "Could not find port with name=%s\n",
                  PortName.c_str());
  }

  // determine which write to use
  if( UseVPI ){
    data = readPortVPI(PortName);
  }else{
    unsigned Idx = PortMap.at(PortName);
    DirectReadFunc Func = std::get<V_READFUNC>(Ports[Idx]);
    data = (*Func)(Top);
  }

  return data;
}

@VERILATOR_SST_PORT_IO_IMPLS@

@VERILATOR_SST_PORT_HANDLER_IMPLS@

} // namespace SST::VerilatorSST

// EOF
